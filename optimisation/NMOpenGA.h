/* NMMosra.h
 *
 * Copyright 2023 Manaaki Whenua - Landcare Research New Zealand Ltd
 * Author: Alexander Herzig
 *
 * This file is part of 'LUMASS', which is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/*  NOTE: The code below was partly generated by the opanGA code generator
 *  and modified for the use with LUMASS.
 *
 */

#ifndef NMOPENGA_H
#define NMOPENGA_H

#include <QMap>
#include <QVector>
#include <QString>
#include <QStringList>


#include <string>
#include <sstream>
#include <iostream>
#include <fstream>
#include <vector>
#include <stdexcept>

#include "otbAttributeTable.h"
#include "otbSQLiteTable.h"

#include "openGA.hpp"

using std::string;
using std::cout;
using std::endl;
using std::vector;
using std::stringstream;

struct NMSolution
{
    // variable name, variable index into (outer) dVars and (outer) dBnds
    // std::map<string, int> varIdxMap;

    // outer: vector of decision variables; one entry per defined variable
    //        in the associated *.los file
    // mid  : vector of OPTIONS per DVAR (1 | OPTIONS)
    //        if the decision variable is defined for each individual land-use
    //        option, this vector contains the boundary or variable value
    //        for each land-use options in the order options are defined in the
    //        associated *.los file
    // inner: values for each individual decision variable;
    //        NOTE: length of this vector is the same for each 'mid' vector, i.e.
    //              land-use-specific sub-type of the given decision variable;
    //              however, it may differ amongst variables defined at different
    //              spatial scales (and represented in outer vector),
    //              e.g. lu vs Nmit vs F_f (s. below)
    //
    //        NOTE2: Individual variable values maybe identified with the help of the
    //               variable-dimensions-offset-map (dimOffsetMap) data member of the
    //               VarAdmin structure of a given decision variable (s. mmVarAdminMap).
    //               The offset map stores the global variable offset (0-based), i.e.
    //               the mapped value, for each individual decision variable (stored in
    //               the inner vector) that can be identified by it's distinct dimension
    //               value combination (i.e. the key). The dimension value combination for
    //               an individual decision variables is stored in a vector (QVector<long long>)
    //               in the order defined in the variable definition in the *.los file.
    //
    //               Example:
    //                  *.los file
    //                      VAR_0=lu SDU OPTIONS : c 0 AreaHa
    //                      VAR_1=Nmit Farm Rec OPTIONS : c 0 MaxNmit
    //
    //                   code
    //                       QMap<QVector<long long>, long long>& doffMap =
    //                          mVarAdminMap["Nmit"].dimOffsetMap;
    //
    //                       QVector<long long> dimCombo = {233453, 11343458, 4};
    //                       long long globalOffset      = doffMap[dimCombo];
    //
    //                       // localOffset is the 0-based index into the inner dVars or varBnds vector
    //                       long long localOffset       = globalOffset - doffMap.cbegin().value();

    std::vector<std::vector<std::vector<float> > > dVars;


    string to_string() const
    {
        //stringstream ss;
        //for (int i=0; i < lu.size(); ++i)
        //{
        //    ss << std::to_string(lu[i]);
        //    if (i < lu.size()-1)
        //    {
        //        ss << " ";
        //    }
        //}

        return "info overload!";
    }
};

struct NMMiddleCost
{
    // This is where the results of simulation
    // is stored but not yet finalized.
    double totalProfit;
    // sum opt and cur N loss sums over FMU_SW
    //       fmu_sw   optNLoss
    std::map<size_t, double> fmuOPTNloss;
    //         fmu_sw           lugrp area
    //std::map<size_t, std::map<int, double> >fmuCURNloss;
    // total lu sums
    // grps:
    // 0 : dai:    0, 1, 2
    // 1 : snb:    3, 4, 5
    // 2 : hap:    6, 7
    // 3 : hav:    8, 9
    // 4 : hbl:    10, 11
    // 5 : hch:    12, 13
    // 6 : hkgr:   14, 15
    // 7 : hkgd:   16, 17
    // 8 : hgp:    18, 19
    // 9 : hgs:    20, 21
    // 10 : von:    22, 23, 24
    // 11 : vpt:    25, 26, 27
    // 12 : amz:    28, 29, 30
    // 13 : ape:    31, 32, 33
    // 14 : awt:    34, 35, 36
    // 15 : fst:    37
    // 16 : flg:    38
    // 17 : nat:    39
    std::map<size_t, std::map<int, double> > luProps;
    std::map<size_t, std::map<int, double> > luPropsAchievedRatio;
};

typedef EA::Genetic<NMSolution,NMMiddleCost> GA_Type;
typedef EA::GenerationType<NMSolution,NMMiddleCost> Generation_Type;

class   NMOpenGA
{
public:
    string mOutputFileName;
    std::ofstream output_file;

    double mConstraintTolerance;
    size_t mNumSolutionsMapped;

    itk::ProcessObject* mProcObj;
    NMLogger* mLogger;

    // names for land-use groups
    std::vector<std::string> mLuGrpName;

    QMap<QString, VarAdmin> mVarAdminMap;

    // variable name, variable index into (outer) dVars and (outer) dBnds
    std::map<string, size_t> varIdxMap;

    // outer: vector of decision variables; one entry per defined variable
    //        in the associated *.los file
    // mid  : vector of OPTIONS per DVAR (1 | OPTIONS)
    //        if the decision variable is defined for each individual land-use
    //        option, this vector contains the boundary (varBnds) or variable value
    //        (dVars) for each land-use options in the order options are defined in the
    //        associated *.los file
    // inner: - pair of <lower, upper> bounds for each variable (for varBnds)
    //        - value of each variable (dVars)
    //        NOTE: length of this vector is the same for each 'mid' vector, i.e.
    //              land-use-specific sub-type of the given decision variable;
    //              however, it may differ amongst variables defined at different
    //              spatial scales/dimensions (outer vector), e.g. lu vs Nmit vs F_f (s. below)
    //        NOTE2: This vector stores the row values for a each distinct decision variable
    //               (per land-use sub-type (i.e. elements of the mid-vector)) inside the
    //               mData structure for each distinct combination of dimension
    //               values this decision variable is defined over
    //
    // Example:
    //  Definitions from *.los file
    //    land-use options: opt=0..39:  0=dai  1=dai_gw  2=dai_sw ... 39=nat
    //    lu[SDU][OPTIONS]
    //    Nmit[Farm][Rec][OPTIONS]
    //    F_5[Rec]

    //  varIdxMap  : (lu, 0); (Nmit, 1); (F_5, 2); ...
    //

    //  lower bound lu_0   : varIdxMap["lu"]    ->  0 -> varBnds[0][0][row].first
    //  upper bound lu_39  : varIdxMap["lu"]    ->  0 -> varBnds[0][39][row].second
    //  ...
    //  upper bound Nmit_4 : varIdxMap["Nmit"]  ->  1 -> varBnds[1][4][row].second
    //  ...
    //  lower bound F_5    : varIdxMap["F_5"]   ->  2 -> varBnds[2][0][row].first
    std::vector<std::vector<std::vector<std::pair<float, float> > > > varBnds;


    // {0,1} vector for each lu * SDU combo (used for genes_init and mutation)
    // it specifies whether a given land-use is allowed to be allocated to a
    // given SDU (1) or not (0)
    // outer vector: land-use options (=column) (i.e. holds a row vector for each land-use option)
    // inner vector: control info for individual SDUs (=rows)
    std::vector<std::vector<unsigned char> > mLucCtrl;

    // Total Area values for individual zones. Zones can be defined over
    // different scales or for different types, e.g. regions, farms, catchments, etc.
    // Each zone type in turn contains discrete units belonging to the same type, e.g.
    // freshwater mananagement units, farms (properties), individual districts, etc.
    // The data structure below stores for each SDU (spatial decision unit (=row)) the total area
    // of each individual zone of a given type that intersects with the given SDU. As SDUs are
    // the smallest geometrical building block in the dataset, only one individual unit of a
    // given type can ever intersect with a given SDU.
    //
    // outer vector: row-vector (with one entry per SDU) for a given zone type (=scale)
    // inner vector: vector of total unit areas for unit the given SDU (row) falls into (intersects with)
    //std::vector<std::vector<double> > mZoneAreaTotals;
    //--> it's in mData

    std::vector<std::string> mMinAreaFields;
    std::map<size_t, size_t> mLuIdPropIdMap;

    // characteristics of spatial dimensions, e.g. TotalArea, Total N loss, ...

    // as list of dimension (zone) names we have 'total' charactersistics for
    // each unique dimension value for
    //std::vector<std::string> mDimensionAttrNames;
    // <dim name, <dim unique value, characteristic value> >
    std::map<std::string, std::map<size_t, double> > mDimensionArea;

    // zonal BL performance
    std::vector<std::string> mBLSumDimensionNames;

    // dimension, map<dim_zone<vector<attribute> > >
    std::map<std::string, std::map<size_t, std::vector<double> > > mDimZoneTotalAttr;


    std::map<std::string, std::vector<size_t> > nameValPosMap;
    // db extract (optFeat == 1) of data required for calculating
    // the solution fitness and the constraints satisfaction
    // outer vector : table rows       // defines set of SDUs length = num of SDUs
    // inner vector : table columns    // defines a record of the table; length = num of columns
    std::vector<std::vector<otb::AttributeTable::ColumnValue> > mData;

    NMOpenGA() : mNumSolutionsMapped(1), mProcObj(nullptr), mLogger(nullptr), mConstraintTolerance(0.2)
    {
        mLuIdPropIdMap.insert(std::pair<size_t, size_t>(0  , 0  ));
        mLuIdPropIdMap.insert(std::pair<size_t, size_t>(1  , 0  ));
        mLuIdPropIdMap.insert(std::pair<size_t, size_t>(2  , 0  ));
        mLuIdPropIdMap.insert(std::pair<size_t, size_t>(3  , 1  ));
        mLuIdPropIdMap.insert(std::pair<size_t, size_t>(4  , 1  ));
        mLuIdPropIdMap.insert(std::pair<size_t, size_t>(5  , 1  ));
        mLuIdPropIdMap.insert(std::pair<size_t, size_t>(6  , 2  ));
        mLuIdPropIdMap.insert(std::pair<size_t, size_t>(7  , 2  ));
        mLuIdPropIdMap.insert(std::pair<size_t, size_t>(8  , 3  ));
        mLuIdPropIdMap.insert(std::pair<size_t, size_t>(9  , 3  ));
        mLuIdPropIdMap.insert(std::pair<size_t, size_t>(10 , 4  ));
        mLuIdPropIdMap.insert(std::pair<size_t, size_t>(11 , 4  ));
        mLuIdPropIdMap.insert(std::pair<size_t, size_t>(12 , 5  ));
        mLuIdPropIdMap.insert(std::pair<size_t, size_t>(13 , 5  ));
        mLuIdPropIdMap.insert(std::pair<size_t, size_t>(14 , 6  ));
        mLuIdPropIdMap.insert(std::pair<size_t, size_t>(15 , 6  ));
        mLuIdPropIdMap.insert(std::pair<size_t, size_t>(16 , 7  ));
        mLuIdPropIdMap.insert(std::pair<size_t, size_t>(17 , 7  ));
        mLuIdPropIdMap.insert(std::pair<size_t, size_t>(18 , 8  ));
        mLuIdPropIdMap.insert(std::pair<size_t, size_t>(19 , 8  ));
        mLuIdPropIdMap.insert(std::pair<size_t, size_t>(20 , 9  ));
        mLuIdPropIdMap.insert(std::pair<size_t, size_t>(21 , 9  ));
        mLuIdPropIdMap.insert(std::pair<size_t, size_t>(22 , 10 ));
        mLuIdPropIdMap.insert(std::pair<size_t, size_t>(23 , 10 ));
        mLuIdPropIdMap.insert(std::pair<size_t, size_t>(24 , 10 ));
        mLuIdPropIdMap.insert(std::pair<size_t, size_t>(25 , 11 ));
        mLuIdPropIdMap.insert(std::pair<size_t, size_t>(26 , 11 ));
        mLuIdPropIdMap.insert(std::pair<size_t, size_t>(27 , 11 ));
        mLuIdPropIdMap.insert(std::pair<size_t, size_t>(28 , 12 ));
        mLuIdPropIdMap.insert(std::pair<size_t, size_t>(29 , 12 ));
        mLuIdPropIdMap.insert(std::pair<size_t, size_t>(30 , 12 ));
        mLuIdPropIdMap.insert(std::pair<size_t, size_t>(31 , 13 ));
        mLuIdPropIdMap.insert(std::pair<size_t, size_t>(32 , 13 ));
        mLuIdPropIdMap.insert(std::pair<size_t, size_t>(33 , 13 ));
        mLuIdPropIdMap.insert(std::pair<size_t, size_t>(34 , 14 ));
        mLuIdPropIdMap.insert(std::pair<size_t, size_t>(35 , 14 ));
        mLuIdPropIdMap.insert(std::pair<size_t, size_t>(36 , 14 ));
        mLuIdPropIdMap.insert(std::pair<size_t, size_t>(37 , 15 ));
        mLuIdPropIdMap.insert(std::pair<size_t, size_t>(38 , 16 ));
        mLuIdPropIdMap.insert(std::pair<size_t, size_t>(39 , 17 ));

        mLuGrpName = {"dai", "snb", "hap", "hav", "hbl", "hch", "hkgr", "hkgd", "hgp", "hgs", "von", "vpt", "amz", "ape", "awt", "fst", "flg", "nat"};

        if (!mOutputFileName.empty())
        {
            output_file.open(mOutputFileName.c_str(), std::ofstream::out | std::ofstream::app);
        }
    }

    ~NMOpenGA()
    {
        output_file.close();
    }

    void setConstraintTolerance(double tol)
    {mConstraintTolerance = tol;}

    bool mapGASolutions(GA_Type& ga_obj,
                        otb::SQLiteTable::Pointer& sqlTab,
                        std::vector<std::string>& options,
                        std::string msOptFeat,
                        NMLogger*& log,
                        QMap<QString, QStringList>& mslParams
                        )
    {
        bool ret = true;

        const std::string luname = "OPT_STR";

        //for (int s=0; s < mNumSolutionsMapped; ++s)
        {
            const NMSolution& sol = ga_obj.last_generation.chromosomes[ga_obj.last_generation.best_chromosome_index].genes;

            // only really need the SDU field
            // need to automate this ::
            std::vector<std::string> getnames;
            getnames.push_back("rowidx");

            std::vector<otb::AttributeTable::ColumnValue> getvalues;
            otb::AttributeTable::ColumnValue getCV;
            getvalues.push_back(getCV);

            std::map<std::string, size_t> getNamesPos;
            getNamesPos.insert(std::pair<std::string, size_t>("SDU", getnames.size()-1));

            //std::vector<std::string> whereCols = getnames;
            //std::vector<otb::AttributeTable::ColumnValue> keyValues;
            //keyValues.type = otb::AttributeTable::ATTYPE_INT;
            //keyValues.push_back(getCV);

            std::map<std::string, size_t> colValuesPos;
            std::vector<std::string> colNames;
            std::vector<otb::AttributeTable::ColumnValue> colValues;

            sqlTab->BeginTransaction();
            for (auto vit : varIdxMap)
            {
                if (vit.first.compare("lu") == 0)
                {
                    colNames.push_back(luname);

                    colValuesPos.insert(std::pair<std::string, size_t>(luname, colValues.size()));

                    otb::AttributeTable::ColumnValue optCV;
                    optCV.type = otb::AttributeTable::ATTYPE_STRING;
                    colValues.push_back(optCV);
                    sqlTab->AddColumn(luname, optCV.type);
                }
                else
                {
                    for (int opt=0; opt < varBnds[varIdxMap[vit.first]].size(); ++opt)
                    {
                        std::stringstream cname;
                        cname << vit.first << "_" << options[opt];
                        colNames.push_back(cname.str());

                        colValuesPos.insert(std::pair<std::string, size_t>(cname.str(), colValues.size()));

                        otb::AttributeTable::ColumnValue vcol;
                        vcol.type = otb::AttributeTable::ATTYPE_DOUBLE;

                        sqlTab->AddColumn(cname.str(), vcol.type);
                        colValues.push_back(vcol);
                    }
                }

                // process dimension parameters of variables (except for 'OPTIONS')
                for (int d=0; d < mVarAdminMap[vit.first.c_str()].dimensions.size(); ++d)
                {
                    const std::string dname = mVarAdminMap[vit.first.c_str()].dimensions.at(d).toStdString();
                    if (dname.compare("OPTIONS") != 0)
                    {
                        const std::string parName = mslParams[dname.c_str()][0].toStdString();
                        getnames.push_back(parName);
                        getNamesPos.insert(std::pair<std::string, size_t>(dname, getnames.size()-1));
                        otb::AttributeTable::ColumnValue dcv;
                        getvalues.push_back(dcv);
                    }
                }
            }
            sqlTab->EndTransaction();

            sqlTab->BeginTransaction();
            // get query
            std::stringstream getQuery;
            getQuery << "where \"" << msOptFeat << "\" == 1";
            if (!sqlTab->PrepareBulkGet(getnames, getQuery.str()))
            {
                sqlTab->EndTransaction();
                return false;
            }

            // set query
            if (!sqlTab->PrepareBulkSet(colNames, false))
            {
                sqlTab->EndTransaction();
                return false;
            }

            // get the first row
            bool brow = sqlTab->DoBulkGet(getvalues);
            if (!brow)
            {
                sqlTab->EndTransaction();
                return false;
            }

            // -----------------------------------------------
            do
            {
                // iterate over variable and populate colValues vector
                for (auto vit : varIdxMap)
                {
                    const std::string variableName = vit.first;
                    QVector<long long> vdims;
                    const QStringList& dimensions = mVarAdminMap[vit.first.c_str()].dimensions;
                    const bool bOptions = dimensions.contains("OPTIONS") ? true : false;
                    const size_t ndims = bOptions ? dimensions.size()-1 : dimensions.size();

                    for (int d=0; d < ndims; ++d)
                    {
                        vdims.push_back(getIntColValue(getvalues[getNamesPos[dimensions[d].toStdString()]]));
                    }

                    if (bOptions)
                    {
                        vdims.push_back(0);
                    }

                    // note: dvarRowOff is 0-based consecutive and relative to the 'extracted' optimisation
                    // region (optFeat == 1) from the optimisation database (layer). It is defined when spatial
                    // dimensions for all defined equations (*.los file) (e.g. SDU and OPTIONS in
                    // EQN_11=Profit:  sum{SDU}(sum{OPTIONS}(Profit_lu))) are analysed
                    const size_t dvarRowOff = static_cast<size_t>(mVarAdminMap[vit.first.c_str()].dimOffsetMap[vdims]);

                    // handle invoid dvarRowOff value
                    if (dvarRowOff >= sol.dVars[varIdxMap[vit.first]][0].size())
                    {
                        for (int ncv=0; ncv < colValues.size(); ++ncv)
                        {
                            if (colValues[ncv].type == otb::AttributeTable::ATTYPE_STRING)
                            {
                                colValues[ncv].slen = 1;
                                colValues[ncv].tval = new char[1];
                                ::sprintf(colValues[ncv].tval, "%s", "\0");
                            }
                            else
                            {
                                colValues[ncv].dval = 0.0;
                            }
                        }
                        log->processLogMsg(QDateTime::currentDateTime().time().toString(),
                                           NMLogger::NM_LOG_ERROR,
                                           "The row offset in VarAdminMap doesn't point to a valid "
                                           "decision variable value!");
                        continue;
                    }

                    // for the land-use variable, we need to translate to land-use option first
                    if (vit.first.compare("lu") == 0)
                    {
                        int optId = -1;
                        for (int q=0; q < options.size(); ++q)
                        {
                            if (sol.dVars[varIdxMap[vit.first]][q][dvarRowOff] > 0)
                            {
                                optId = q;
                                break;
                            }
                        }
                        const size_t lucvp = colValuesPos[luname];

                        if (optId == -1)
                        {
                            colValues[lucvp].slen = 1;
                            colValues[lucvp].tval = new char[1];
                            ::sprintf(colValues[lucvp].tval, "%s", "\0");
                        }
                        else
                        {
                            const std::string luopt = options.at(optId);
                            colValues[lucvp].slen = luopt.size();
                            colValues[lucvp].tval = new char[luopt.size()];
                            ::sprintf(colValues[lucvp].tval, "%s", luopt.c_str());
                        }
                    }
                    else
                    {
                        for (int u=0; u < sol.dVars[varIdxMap[vit.first]].size(); ++u)
                        {
                            std::stringstream cname;
                            cname << vit.first << "_" << options[u];
                            const size_t cvp = colValuesPos[cname.str()];

                            colValues[cvp].dval = sol.dVars[varIdxMap[vit.first]][u][dvarRowOff];
                        }
                    }
                }

                // put the data in
                const long long sdu = getIntColValue(getvalues[getNamesPos["SDU"]]);
                if (!sqlTab->DoBulkSet(colValues, sdu))
                {
                    sqlTab->EndTransaction();
                    return false;
                }

                brow = sqlTab->DoBulkGet(getvalues);
            } while (brow);
            // ------------------------------------------------------


            sqlTab->EndTransaction();
        }

        return ret;
    }

    // just to make sure we get the type we want or 'zero' performance!
    inline long long getIntColValue(const otb::AttributeTable::ColumnValue& colValue)
    {
        long long ret;
        switch(colValue.type)
        {
        case otb::AttributeTable::ATTYPE_INT:
            ret = colValue.ival;
            break;
        case otb::AttributeTable::ATTYPE_DOUBLE:
            ret = static_cast<long long>(colValue.dval);
            break;
        case otb::AttributeTable::ATTYPE_STRING:
            ret = std::stoll(colValue.tval);
            break;
        default:
            ;
        }
        return ret;
    }

    inline double    getDblColValue(const otb::AttributeTable::ColumnValue& colValue)
    {
        double ret;
        switch(colValue.type)
        {
        case otb::AttributeTable::ATTYPE_INT:
            ret = static_cast<double>(colValue.ival);
            break;
        case otb::AttributeTable::ATTYPE_DOUBLE:
            ret = colValue.dval;
            break;
        case otb::AttributeTable::ATTYPE_STRING:
            ret = std::stod(colValue.tval);
            break;
        default:
            ;
        }
        return ret;
    }

    void init_solution(NMSolution& sol)
    {
        // creates 'column structure' for decision variables
        for (auto vars : varIdxMap)
        {
            std::vector<std::vector<float> > varsVec;
            size_t sz = sol.dVars.size();
            sol.dVars.push_back(varsVec);
            for (int mv=0; mv < varBnds[vars.second].size(); ++mv)
            {
                std::vector<float> orvec;
                sol.dVars[sz].push_back(orvec);
            }
        }
    }

    void init_genes(NMSolution& p,const std::function<double(void)> &rnd01)
    {
        const size_t numOptions = mLucCtrl.size();
        const size_t luColIdx = varIdxMap["lu"];
        const size_t fmuswId = nameValPosMap["FMU_SW"][0];
        //const size_t fmuswhaId = nameValPosMap["FMU_SW_ha"][0];

        // creates decision vars column structure
        init_solution(p);

        // iterate over rows and initiate decision variable
        // values for each distinct location they're defined for
        // init decision variables within user-defined bounds
        for (auto vit : varIdxMap)
        {
            //const VarAdmin& vad = mVarAdminMap[vit.first.c_str()];

            // 'spatially distinct' locations of a given decision variable
            const size_t varrows = varBnds[varIdxMap[vit.first]][0].size();

            //auto offit = vad.dimOffsetMap.cbegin();
            for (int vrow=0; vrow < varrows; ++vrow)
            {
                // either lower bound (=0) or upper (=AreaHa)
                if (vit.first.compare("lu") == 0)
                {
                    // draw a new random land-use that is allowed to be allocated to the given SDU, i.e. gotcha == 1
                    // however, need to test whether any of the land-uses is allowed in the first place!
                    //std::vector<unsigned char> luid_forDraw;

                    // get the FMU_SW value
                    const size_t fmuswVal = getIntColValue(mData[vrow][fmuswId]);

                    bool randomDraw = false;
                    for (int k=0; k < numOptions; ++k)
                    {
                        if (mLucCtrl[k][vrow] == 1)
                        {
                            //luid_forDraw.push_back(k);
                            randomDraw = true;
                            break;
                        }
                    }

                    unsigned char luid = numOptions;
                    unsigned char gotcha = 0;

                    if (randomDraw)
                    {
                        // need to randomly pick a land-use based on proportion
                        // build in somehow the proportion !
                        // -> order lu by proportion
                        // prop = 1 - rnd01()
                        // pick lu with prop closest to prop; if there are more than one
                        // with similar prop, pick randomly

                        do
                        {
                            // pick a land-use
                            luid = static_cast<unsigned char>((numOptions-1) * rnd01() + 0.5);
                            gotcha = mLucCtrl[luid][vrow];
                            if (gotcha != 1)
                            {
                                continue;
                            }

                            // consider proportion of lu with respect to given domain
                            const size_t minAreaFieldId = static_cast<size_t>(mLuIdPropIdMap[luid]);
                            const std::string minAreaField = mMinAreaFields[minAreaFieldId];
                            const double minArea = getDblColValue(mData[vrow][nameValPosMap[minAreaField][0]]);
                            const double totalArea = mDimensionArea["FMU_SW"][fmuswVal];
                            if (rnd01() <= (1-(minArea/totalArea)))
                            {
                                gotcha = 0;
                                continue;
                            }

                        } while (gotcha != 1);

                        p.dVars[luColIdx][luid].push_back(varBnds[luColIdx][luid][vrow].second);
                    }

                    // now fill the rest, i.e. those which aren't == luid with '0'
                    for (int v=0; v < numOptions; ++v)
                    {
                        if (v != luid)
                        {
                            p.dVars[luColIdx][v].push_back(0.0);
                        }
                    }
                }
                // any value between lower and upper limit is OK
                else
                {
                    // iterate over middle vector (i.e. variables)
                    for (int nvars=0; nvars < varBnds[vit.second].size(); ++nvars)
                    {
                        const float lowBnd = varBnds[vit.second][nvars][vrow].first;
                        const float highBnd = varBnds[vit.second][nvars][vrow].second;
                        float varVal =  lowBnd + (highBnd-lowBnd) * rnd01();

                        p.dVars[vit.second][nvars].push_back(varVal);
                    }
                }
            }
        }
    }

    bool eval_solution(
            const NMSolution& p,
            NMMiddleCost &c
            )
    {
        bool accepted = true;

        const int numOptions = mLucCtrl.size();

        // prime solutions
        c.totalProfit = 0;

        // init luProps map
        std::vector<std::string> minFields = mMinAreaFields;

        auto fmuit = mDimensionArea["FMU_SW"].cbegin();
        for (; fmuit != mDimensionArea["FMU_SW"].cend(); ++fmuit)
        {
            std::map<int, double> emptyLuAreaMap;
            c.luProps.insert(std::pair<size_t, std::map<int, double> >(fmuit->first, emptyLuAreaMap));
            c.luPropsAchievedRatio.insert(std::pair<size_t, std::map<int, double> >(fmuit->first, emptyLuAreaMap));

            for (int m=0; m < minFields.size(); ++m)
            {
                c.luProps[fmuit->first].insert(std::pair<int, double>(m, 0.0));
                c.luPropsAchievedRatio[fmuit->first].insert(std::pair<int, double>(m, 0.0));
            }
        }

        const size_t areaId = nameValPosMap["AreaHa"][0];
        const size_t sduId = nameValPosMap["SDU"][0];
        const size_t farmId = nameValPosMap["Farm"][0];
        const size_t recId = nameValPosMap["Rec"][0];
        const size_t ophId = nameValPosMap["Oph"][0];
        const size_t nslpId = nameValPosMap["Nslp"][0];
        const size_t nbaseId = nameValPosMap["Nbase"][0];
        //const size_t nbllossId = nameValPosMap["N_BaselineLoss"][0];
        const size_t fmuId = nameValPosMap["FMU_SW"][0];

        const QMap<QVector<long long>, long long>& luOffMap = mVarAdminMap["lu"].dimOffsetMap;
        const QMap<QVector<long long>, long long>& nmitOffMap = mVarAdminMap["Nmit"].dimOffsetMap;

        const size_t luVarColOff = varIdxMap["lu"];
        const size_t nmitVarColOff = varIdxMap["Nmit"];

        // iterating over the 'table'
        // and calculate the fitness
        for (int row=0; row < mData.size(); ++row)
        {
            const long long fmu = getIntColValue(mData[row][fmuId]);
            const long long sdu = getIntColValue(mData[row][sduId]);
            const long long rec = getIntColValue(mData[row][recId]);
            const long long farm = getIntColValue(mData[row][farmId]);
            //const double curNloss = mDimZoneTotalAttr["FMU_SW"][fmu][0];
            //const double curNloss = getDblColValue(mData[row][nbllossId]);
            double optNloss = 0;

            for (int opt=0; opt < numOptions; ++opt)
            {
                const QVector<long long> luDims = {sdu, opt};
                const QVector<long long> nmitDims = {farm, rec, opt};

                const size_t luVarRowOff = luOffMap[luDims];

                float Nmit = 0.0;
                if (nmitOffMap.constFind(nmitDims) != nmitOffMap.constEnd())
                {
                    const size_t nmitVarRowOff = nmitOffMap[nmitDims];
                    Nmit = p.dVars[nmitVarColOff][opt][nmitVarRowOff];
                }


                optNloss +=   p.dVars[luVarColOff][opt][luVarRowOff]
                        * getDblColValue(mData[row][nbaseId+opt])
                        * (1 - Nmit);

                c.totalProfit +=   p.dVars[luVarColOff][opt][luVarRowOff]
                        * getDblColValue(mData[row][ophId+opt])
                        * (1 - Nmit * getDblColValue(mData[row][nslpId+opt]));

                // sum lu props
                const int lupropsid = mLuIdPropIdMap[opt];
                const double lprop = p.dVars[luVarColOff][opt][luVarRowOff];
                c.luProps[fmu][lupropsid] += lprop;
            }

            if (c.fmuOPTNloss.find(fmu) == c.fmuOPTNloss.cend())
            {
                //c.fmuCURNloss.insert(std::pair<int, double>(fmu, curNloss));
                c.fmuOPTNloss.insert(std::pair<int, double>(fmu, optNloss));
            }
            else
            {
                //c.fmuCURNloss[fmu] += curNloss;
                c.fmuOPTNloss[fmu] += optNloss;
            }

            // if this is the last row, we check the are constraints
            if (row == mData.size()-1)
            {
                // check all fmu_sw s .. one after the other
                bool innerAccepted = true;
                double regionsFailed = 0;
                double regionBase = 0;

                auto lpit = c.luProps.cbegin();
                for (; lpit != c.luProps.cend(); ++lpit)
                {
                    const size_t fmu2 = lpit->first;
                    regionBase += 1;


                    // check the luprops constraints at the individual zone level (fmu_sw)
                    double numFailed = 0;
                    double propBase = 0;
                    for (int lp=0; lp < minFields.size(); ++lp)
                    {
                        const size_t minFieldId = nameValPosMap[minFields[lp]][0];
                        const double minProp = getDblColValue(mData[row][minFieldId]);
                        double targetDeviation = 0;
                        double luPropRatio = 0;
                        if (minProp > 0)
                        {
                            // just bother with the undershoots!
                            if (c.luProps[fmu2][lp] < (minProp - mConstraintTolerance*minProp))
                            {
                                targetDeviation = std::abs((minProp - c.luProps[fmu2][lp])/minProp);
                                ++numFailed;
                            }
                            luPropRatio = c.luProps[fmu2][lp] / minProp;
                            ++propBase;
                        }

                        c.luPropsAchievedRatio[fmu2][lp] = luPropRatio;
                    }
                    if (numFailed / (double)propBase > mConstraintTolerance)
                    {
                        innerAccepted = false;
                        regionsFailed += 1;
                    }
                }
                if (regionsFailed / regionBase > mConstraintTolerance)
                {
                    accepted = false;
                }
            }
        }

        // check the Nloss constraint
        for (auto fmu : c.fmuOPTNloss)
        {
            // note order of DimZoneAttrs: {"N_BL", "P_BL", "SW_BL", "GW_BL"}
            const double curNloss = this->mDimZoneTotalAttr["FMU_SW"][fmu.first][0];
            if (curNloss <= fmu.second)
            {
                accepted = false;
                break;
            }
        }

        return accepted; // solution is accepted
    }

    NMSolution mutate(
            const NMSolution& X_base,
            const std::function<double(void)> &rnd01,
            double shrink_scale)
    {
        NMSolution X_new;

        const size_t numOptions = mLucCtrl.size();
        const size_t luColIdx = varIdxMap["lu"];
        const size_t fmuswId = nameValPosMap["FMU_SW"][0];

        init_solution(X_new);

        for (auto vit : varIdxMap)
        {
            // 'spatially distinct' locations of a given decision variable
            const size_t varrows = varBnds[varIdxMap[vit.first]][0].size();

            //auto offit = vad.dimOffsetMap.cbegin();
            for (size_t vrow=0; vrow < varrows; ++vrow)
            {
                // ---------------------------------------------------------------
                // just takeover a given portion straight from X_base or ...

                if (rnd01() >= shrink_scale)
                {
                    // iterate over middle vector (i.e. variables)
                    for (int nvars=0; nvars < varBnds[vit.second].size(); ++nvars)
                    {
                        X_new.dVars[vit.second][nvars].push_back(X_base.dVars[vit.second][nvars][vrow]);
                    }
                }
                // ---------------------------------------------------------------
                // ... do a new random allocation
                else
                {
                    // either lower bound (=0) or upper (=AreaHa)
                    if (vit.first.compare("lu") == 0)
                    {
                        // draw a new random land-use that is allowed to be allocated to the given SDU, i.e. gotcha == 1
                        // however, need to test whether any of the land-uses is allowed in the first place!
                        //std::vector<unsigned char> luid_forDraw;

                        // get the FMU_SW value
                        const size_t fmuswVal = getIntColValue(mData[vrow][fmuswId]);

                        bool randomDraw = false;
                        for (int k=0; k < numOptions; ++k)
                        {
                            if (mLucCtrl[k][vrow] == 1)
                            {
                                //luid_forDraw.push_back(k);
                                randomDraw = true;
                                break;
                            }
                        }

                        unsigned char luid = numOptions;
                        unsigned char gotcha = 0;

                        if (randomDraw)
                        {
                            // need to randomly pick a land-use based on proportion
                            // build in somehow the proportion !
                            // -> order lu by proportion
                            // prop = 1 - rnd01()
                            // pick lu with prop closest to prop; if there are more than one
                            // with similar prop, pick randomly

                            do
                            {
                                // pick a land-use
                                luid = static_cast<unsigned char>((numOptions-1) * rnd01() + 0.5);
                                gotcha = mLucCtrl[luid][vrow];
                                if (gotcha != 1)
                                {
                                    continue;
                                }

                                // consider proportion of lu with respect to given domain
                                const size_t minAreaFieldId = static_cast<size_t>(mLuIdPropIdMap[luid]);
                                const std::string minAreaField = mMinAreaFields[minAreaFieldId];
                                const double minArea = getDblColValue(mData[vrow][nameValPosMap[minAreaField][0]]);
                                const double totalArea = mDimensionArea["FMU_SW"][fmuswVal];
                                if (rnd01() <= (1-(minArea/totalArea)))
                                {
                                    gotcha = 0;
                                    continue;
                                }

                            } while (gotcha != 1);

                            X_new.dVars[luColIdx][luid].push_back(varBnds[luColIdx][luid][vrow].second);
                        }

                        // now fill the rest, i.e. those which aren't == luid with '0'
                        for (int v=0; v < numOptions; ++v)
                        {
                            if (v != luid)
                            {
                                X_new.dVars[luColIdx][v].push_back(0.0);
                            }
                        }
                    }

                    /*
                    //if (vit.first.compare("lu") == 0)
                    //{
                    //    // draw a new random land-use that is allowed to be allocated to the given SDU, i.e. gotcha == 1
                    //    // however, need to test whether any of the land-uses is allowed in the first place!
                    //    bool randomDraw = false;
                    //    for (int k=0; k < numOptions; ++k)
                    //    {
                    //        if (mLucCtrl[k][vrow] == 1)
                    //        {
                    //            randomDraw = true;
                    //            break;
                    //        }
                    //    }

                    //    unsigned char luid = numOptions;
                    //    unsigned char gotcha = 0;

                    //    if (randomDraw)
                    //    {
                    //        do
                    //        {
                    //          luid = static_cast<unsigned char>((numOptions-1) * rnd01() + 0.5);
                    //          gotcha = mLucCtrl[luid][vrow];
                    //        } while (gotcha != 1);

                    //        X_new.dVars[luColIdx][luid].push_back(varBnds[luColIdx][luid][vrow].second);
                    //    }

                    //    // now fill the rest, i.e. those which aren't == luid with '0'
                    //    for (int v=0; v < numOptions; ++v)
                    //    {
                    //        if (v != luid)
                    //        {
                    //            X_new.dVars[luColIdx][v].push_back(0.0);
                    //        }
                    //    }
                    //}
                    */
                    // any value between lower and upper limit is OK
                    else
                    {
                        // iterate over middle vector (i.e. variables)
                        for (int nvars=0; nvars < varBnds[vit.second].size(); ++nvars)
                        {
                            const float lowBnd = varBnds[vit.second][nvars][vrow].first;
                            const float highBnd = varBnds[vit.second][nvars][vrow].second;
                            float varVal =  lowBnd + (highBnd-lowBnd) * rnd01();

                            X_new.dVars[vit.second][nvars].push_back(varVal);
                        }
                    }
                }
            }
        }

        return X_new;
    }

    NMSolution crossover(
            const NMSolution& X1,
            const NMSolution& X2,
            const std::function<double(void)> &rnd01)
    {
        NMSolution X_new;

        const size_t numOptions = mLucCtrl.size();
        const size_t luColIdx = 0;

        init_solution(X_new);

        // we do a 1-point crossover at the given row for each 'major decision variable'

        for (size_t var=0; var < X1.dVars.size(); ++var)
        {
            const size_t crossOverPoint = static_cast<size_t>(X1.dVars[var][0].size() * rnd01() + 0.5);

            for (size_t opt=0; opt < numOptions; ++opt)
            {
                for (size_t row=0; row < X1.dVars[var][opt].size(); ++row)
                {
                    if (row < crossOverPoint)
                    {
                        X_new.dVars[var][opt].push_back(X1.dVars[var][opt][row]);
                    }
                    else
                    {
                        X_new.dVars[var][opt].push_back(X2.dVars[var][opt][row]);
                    }
                }
            }
        }

        return X_new;
    }

    double calculate_SO_total_fitness(const GA_Type::thisChromosomeType &X)
    {
        return -X.middle_costs.totalProfit;
    }


    void SO_report_generation(
            int generation_number,
            const EA::GenerationType<NMSolution,NMMiddleCost> &last_generation,
            const NMSolution& best_genes)
    {
        std::stringstream rcout;
        rcout.setf(std::ios::fixed);
        rcout.precision(3);

        rcout
                <<"Generation ["<<generation_number<<"], "
               <<"Best="<<last_generation.best_total_cost<<", "
              <<"Average="<<last_generation.average_cost<<", "
                //<<"Best genes=("<<best_genes.to_string()<<")"<<", "
             <<"Exe_time="<<last_generation.exe_time << ", "; // << std::endl;
        cout << rcout.str();

        const int bcidx = last_generation.best_chromosome_index;
        double profit = last_generation.chromosomes[bcidx].middle_costs.totalProfit;

        rcout << "Profit=" << profit << std::endl;

        auto optNit = last_generation.chromosomes[bcidx].middle_costs.fmuOPTNloss.cbegin();

        const int length = last_generation.chromosomes[bcidx].middle_costs.fmuOPTNloss.size();

        // feedback on Nloss constraint
        for(int cnt=0; optNit != last_generation.chromosomes[bcidx].middle_costs.fmuOPTNloss.cend(); ++optNit, ++cnt)
        {
            const double optN   = optNit->second;
            // note mDimZoneTotalAttr order: {"N_BL", "P_BL", "SW_BL", "GW_BL"}
            const double curN   = mDimZoneTotalAttr["FMU_SW"][optNit->first][0];
            const double relred = 100 - optN/curN * 100;
            rcout << "Nred(" << optNit->first << ")=" << relred;

            if (cnt < length-1)
            {
                rcout << ", ";
            }
        }
        rcout << std::endl;

        // feedback on LuProp constraint

        rcout << "Land-use props met: ";

        auto ploit = last_generation.chromosomes[bcidx].middle_costs.luPropsAchievedRatio.begin();
        for (; ploit != last_generation.chromosomes[bcidx].middle_costs.luPropsAchievedRatio.end(); ++ploit)
        {
            const size_t fmuswVal = ploit->first;
            auto propLenIt = last_generation.chromosomes[bcidx].middle_costs.luPropsAchievedRatio.at(fmuswVal).begin();
            const int propLen = last_generation.chromosomes[bcidx].middle_costs.luPropsAchievedRatio.at(fmuswVal).size();
            for (int pl=0; propLenIt != last_generation.chromosomes[bcidx].middle_costs.luPropsAchievedRatio.at(fmuswVal).cend(); ++pl, ++propLenIt)
            {
                rcout << mLuGrpName[pl] << "(" << propLenIt->second << ")";
                if (pl < propLen-1)
                {
                    rcout << ", ";
                }
            }
            rcout << std::endl;
        }
        rcout << std::endl << std::endl;

        if (!output_file.is_open())
        {
            output_file.open(mOutputFileName, std::ofstream::out | std::ofstream::app);
        }

        output_file << rcout.str();

        GALOG_INFO(<< rcout.str());
    }

    void setOutputFileName(string& outfilename)
    {
        mOutputFileName = outfilename;
    }

};


#endif // NMOPENGA_H
